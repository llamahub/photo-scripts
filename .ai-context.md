# AI Assistant Context File

This file provides context for AI assistants working on the photo-scripts monorepo. It captures the development philosophy, patterns, and key information needed to maintain consistency with the established architecture.

## Development Philosophy

### Core Principles
1. **Consistency over Convenience**: Predictable patterns are more valuable than shortcuts
2. **Graceful Degradation**: Always provide fallbacks for missing dependencies
3. **Developer-Friendly**: Minimize boilerplate, maximize clarity
4. **Test-Driven**: Comprehensive test coverage enables confident refactoring
5. **DRY (Don't Repeat Yourself)**: Shared infrastructure eliminates duplication

### Design Patterns
- **Composition over Inheritance**: Favor component composition
- **Dependency Injection**: Pass dependencies explicitly
- **Fail Fast**: Validate inputs early and provide clear error messages
- **Immutable Configuration**: Configuration objects shouldn't change after creation

## Framework Architecture

### Monorepo Structure
```
photo-scripts/
├── COMMON/                     # Shared infrastructure
│   ├── src/common/            # Reusable modules
│   │   ├── logging.py         # ScriptLogging class
│   │   ├── config.py          # BaseConfig class
│   │   └── utils.py           # Utility functions
│   ├── scripts/run.py         # Universal script runner
│   ├── common_tasks.py        # Shared invoke tasks
│   └── ARCHITECTURE.md        # Technical documentation
├── EXIF/                      # Example project
│   ├── src/exif/             # Project modules
│   ├── scripts/              # Standalone scripts
│   ├── tests/                # Unit tests
│   └── tasks.py              # Project tasks (extends COMMON)
└── DEVELOPMENT_HISTORY.md     # Context and decisions
```

### Key Components

#### ScriptLogging (COMMON/src/common/logging.py)
**Purpose**: Consistent logging across all scripts
**Usage Pattern**:
```python
from common.logging import ScriptLogging
logger = ScriptLogging.get_script_logger(name="script_name", debug=True)
```
**Features**: Dual output (console + file), timestamped files, debug support, fallback safety

#### Shared Tasks (COMMON/common_tasks.py)
**Purpose**: Eliminate duplicate task definitions
**Extension Pattern**:
```python
# In project tasks.py
from common_tasks import *  # Import shared tasks
@task
def project_specific_task(c): ...  # Add project tasks
```

#### Universal Script Runner (COMMON/scripts/run.py)
**Purpose**: Consistent script execution across projects
**Three execution methods**:
1. `inv r -n script -a 'args'` (shortcut)
2. `invoke run --script script --args 'args'` (traditional)
3. `python ../COMMON/scripts/run.py script args` (direct)

## Standard Patterns

### Script Template
```python
#!/usr/bin/env python3
"""Script description with clear purpose."""

import sys
from pathlib import Path
from datetime import datetime

# Standard COMMON import pattern
common_src_path = Path(__file__).parent.parent.parent / 'COMMON' / 'src'
sys.path.insert(0, str(common_src_path))

try:
    from common.logging import ScriptLogging
except ImportError:
    import logging
    ScriptLogging = None

def main():
    """Main function with proper argument parsing."""
    parser = argparse.ArgumentParser(description="Script description")
    parser.add_argument('--debug', action='store_true', help='Enable debug output')
    args = parser.parse_args()
    
    # Setup logging
    if ScriptLogging:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        logger = ScriptLogging.get_script_logger(
            name=f"script_{timestamp}",
            debug=args.debug
        )
    else:
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger("script")
    
    logger.info("Starting script")
    try:
        # Script logic here
        logger.info("Script completed successfully")
    except Exception as e:
        logger.error(f"Script failed: {e}")
        return 1
    return 0

if __name__ == '__main__':
    sys.exit(main())
```

### Error Handling Pattern
```python
try:
    # Risky operation
    result = risky_operation()
except SpecificError as e:
    logger.warning(f"Expected error handled gracefully: {e}")
    # Provide fallback or continue
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    # Consider whether to continue or fail
```

### Testing Pattern
```python
class TestScriptComponent:
    """Test cases for script component."""
    
    @pytest.fixture
    def temp_dirs(self):
        """Create temporary directories for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            source = temp_path / "source"
            target = temp_path / "target"
            source.mkdir()
            target.mkdir()
            yield source, target
    
    def test_functionality(self, temp_dirs):
        """Test specific functionality with clear assertions."""
        source, target = temp_dirs
        # Test implementation
        assert expected_result == actual_result
```

## Code Quality Standards

### Type Hints
- Use type hints for all function parameters and return values
- Import types from `typing` module when needed
- Use `Path` for file system paths, not strings

### Documentation
- Docstrings for all classes and public methods
- Clear parameter descriptions
- Usage examples in module docstrings

### Error Messages
- Clear, actionable error messages
- Include context about what failed and why
- Suggest next steps when possible

### Logging Levels
- `DEBUG`: Detailed information for debugging
- `INFO`: General information about script progress
- `WARNING`: Something unexpected but script can continue
- `ERROR`: Error condition that prevents script completion

## Integration Guidelines

### Adding New Projects
1. Copy structure from existing project (preferably EXIF)
2. Update `pyproject.toml` with project-specific information
3. Create `tasks.py` that imports from `common_tasks`
4. Add project-specific modules to `src/project_name/`
5. Write comprehensive tests in `tests/`

### Adding New Scripts
1. Follow the standard script template
2. Use ScriptLogging for consistent output
3. Include comprehensive argument parsing
4. Add to project's `scripts/` directory
5. Write unit tests for complex logic

### Adding Shared Functionality
1. Add to appropriate COMMON module
2. Maintain backward compatibility
3. Add comprehensive tests
4. Update documentation
5. Consider impact on existing projects

## Testing Philosophy

### Test Coverage
- Aim for >95% code coverage
- Test both success and failure cases
- Include edge cases and boundary conditions
- Mock external dependencies

### Test Organization
- Mirror source code structure in test directory
- Group related tests in classes
- Use descriptive test method names
- Include docstrings for complex test cases

### Fixtures and Mocks
- Use pytest fixtures for common test setup
- Mock external dependencies (file system, network)
- Create realistic test data
- Clean up resources in fixtures

## Common Pitfalls to Avoid

### Import Issues
- Don't use relative imports across project boundaries
- Always provide fallback for COMMON imports
- Use absolute paths for COMMON module discovery

### Path Handling
- Use `pathlib.Path` consistently, not string concatenation
- Handle cross-platform path differences
- Validate paths before use

### Logging
- Don't mix print() statements with logger calls
- Use appropriate log levels
- Don't log sensitive information

### Error Handling
- Don't catch `Exception` without re-raising or logging
- Provide specific exception handling where possible
- Always include error context in messages

## Performance Considerations

### File Operations
- Use `pathlib.Path` for efficient path operations
- Minimize file system calls in loops
- Consider using generators for large datasets

### Memory Usage
- Process large files in chunks when possible
- Use generators instead of loading entire datasets
- Clean up resources explicitly when needed

### Import Performance
- Use lazy imports for heavy dependencies
- Consider startup time impact of imports
- Cache expensive computations when appropriate

## Security Guidelines

### Path Safety
- Validate all user-provided paths
- Prevent directory traversal attacks
- Use safe path joining methods

### Input Validation
- Validate all user inputs
- Sanitize file paths and names
- Handle unexpected input gracefully

### Environment Isolation
- Use virtual environments consistently
- Don't modify system Python installation
- Pin dependency versions

## Maintenance Guidelines

### Version Control
- Use clear, descriptive commit messages
- Group related changes in single commits
- Tag releases appropriately

### Documentation Updates
- Update documentation when changing APIs
- Keep examples current with code changes
- Document breaking changes clearly

### Backward Compatibility
- Maintain API compatibility when possible
- Deprecate features before removing them
- Provide migration guides for breaking changes

This context file should help maintain consistency and quality when extending or modifying the photo-scripts framework.